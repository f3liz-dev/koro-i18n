// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  output          = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Users table
model User {
  id       String   @id
  githubId Int      @unique
  username String
  email    String
  avatarUrl String?
  githubAccessToken String? // GitHub OAuth token with public_repo scope
  createdAt DateTime @default(now())

  // Relations
  projects              Project[]
  webTranslations       WebTranslation[]
  webTranslationHistory WebTranslationHistory[]
  projectMemberships    ProjectMember[]
  addedMembers          ProjectMember[] @relation("AddedBy")

  @@index([githubId])
}

// OAuth states table (temporary, auto-expire, in-memory only for stateless JWT)
model OauthState {
  state     String   @id
  timestamp Int
  expiresAt DateTime

  @@index([expiresAt])
}

// R2 File Index (GitHub imports - mutable, stored in R2)
// This table stores metadata and pointers to R2, not the actual file contents
// Files are OVERWRITTEN on each upload, git history is in the metadata
model R2File {
  id          String   @id
  projectId   String
  branch      String
  commitSha   String   // Latest commit that modified this file
  lang        String
  filename    String
  r2Key       String   // R2 object key: [project]-[lang]-[filename] (no commit hash)
  sourceHash  String   // Hash of source content
  totalKeys   Int      // Total number of translation keys
  approvedCount Int    @default(0)
  committedCount Int   @default(0)
  uploadedAt  DateTime @default(now())
  lastUpdated DateTime @default(now()) @updatedAt // For ETag

  // Deletion state used to coordinate transactional-like cleanup
  // Set to true when a cleanup worker starts deleting the R2 objects so
  // concurrent processes can detect in-progress deletions and avoid races.
  deleting     Boolean  @default(false)

  // Optional misc metadata R2 key stored alongside main r2Key.
  // This allows cleanup and tooling to know the exact misc object name.
  miscR2Key    String?

  @@unique([projectId, branch, lang, filename])
  @@index([projectId, branch])
  @@index([projectId, lang])
  @@index([lastUpdated])
}

// Web Translations (user-submitted translations via web UI)
// GitHub imports are NOT stored here - they're in R2
model WebTranslation {
  id              String   @id
  projectId       String
  language        String
  filename        String
  key             String   // Flattened key (e.g., "common.welcome")
  value           String
  userId          String
  status          String   @default("pending") // pending, approved, rejected, deleted
  
  // Source tracking (for validation)
  sourceHash      String?  // Hash of source value when translated (for detecting changes)
  isValid         Boolean  @default(true) // False if source changed
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @default(now()) @updatedAt

  // Relations
  user    User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  history WebTranslationHistory[]

  @@index([projectId, language, filename])
  @@index([status])
  @@index([projectId, language, filename, key])
  @@index([updatedAt])
  @@index([isValid])
}

// Web Translation History (audit trail for web translations only)
model WebTranslationHistory {
  id            String   @id
  translationId String
  projectId     String
  language      String
  filename      String
  key           String
  value         String
  userId        String
  action        String   // submitted, approved, rejected, deleted, invalidated
  
  // Source tracking at time of action
  sourceHash    String?  // Hash of source value at time of action
  
  createdAt     DateTime @default(now())

  // Relations
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  translation WebTranslation @relation(fields: [translationId], references: [id], onDelete: Cascade)

  @@index([translationId])
  @@index([projectId, language, filename, key])
  @@index([createdAt])
}

// Projects (Cloudflare-style: simple name + repository binding)
model Project {
  id            String   @id
  userId        String
  name          String   @unique
  repository    String   @unique
  accessControl String   @default("whitelist") // 'whitelist' or 'blacklist'
  sourceLanguage String  @default("en") // Source language for translations
  createdAt     DateTime @default(now())

  // Relations
  user    User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  members ProjectMember[]

  @@index([userId])
  @@index([name])
  @@index([repository])
}

// Project members (users who have access to a project)
model ProjectMember {
  id        String   @id
  projectId String
  userId    String
  status    String   @default("pending") // 'pending', 'approved', 'rejected'
  role      String   @default("member")  // 'owner', 'member'
  addedBy   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  // Relations
  project      Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user         User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  addedByUser  User?   @relation("AddedBy", fields: [addedBy], references: [id], onDelete: SetNull)

  @@unique([projectId, userId])
  @@index([projectId])
  @@index([userId])
  @@index([projectId, status])
}
